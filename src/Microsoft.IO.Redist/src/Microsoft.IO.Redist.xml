<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.IO.Redist</name>
    </assembly>
    <members>
        <member name="M:Interop.Advapi32.EncryptFilePrivate(System.String)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use EncryptFile.
            </summary>
        </member>
        <member name="M:Interop.Advapi32.DecryptFileFilePrivate(System.String,System.Int32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use DecryptFile.
            </summary>
        </member>
        <member name="T:Interop.BOOL">
            <summary>
            Blittable version of Windows BOOL type. It is convenient in situations where
            manual marshalling is required, or to avoid overhead of regular bool marshalling.
            </summary>
            <remarks>
            Some Windows APIs return arbitrary integer values although the return type is defined
            as BOOL. It is best to never compare BOOL to TRUE. Always use bResult != BOOL.FALSE
            or bResult == BOOL.FALSE .
            </remarks>
        </member>
        <member name="T:Interop.BOOLEAN">
            <summary>
            Blittable version of Windows BOOLEAN type. It is convenient in situations where
            manual marshalling is required, or to avoid overhead of regular bool marshalling.
            </summary>
            <remarks>
            Some Windows APIs return arbitrary integer values although the return type is defined
            as BOOLEAN. It is best to never compare BOOLEAN to TRUE. Always use bResult != BOOLEAN.FALSE
            or bResult == BOOLEAN.FALSE .
            </remarks>
        </member>
        <member name="T:Interop.LongFileTime">
            <summary>
            100-nanosecond intervals (ticks) since January 1, 1601 (UTC).
            </summary>
            <remarks>
            For NT times that are defined as longs (LARGE_INTEGER, etc.).
            Do NOT use for FILETIME unless you are POSITIVE it will fall on an
            8 byte boundary.
            </remarks>
        </member>
        <member name="F:Interop.LongFileTime.TicksSince1601">
            <summary>
            100-nanosecond intervals (ticks) since January 1, 1601 (UTC).
            </summary>
        </member>
        <member name="T:Interop.OBJECT_ATTRIBUTES">
            <summary>
            <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff557749.aspx">OBJECT_ATTRIBUTES</a> structure.
            The OBJECT_ATTRIBUTES structure specifies attributes that can be applied to objects or object handles by routines
            that create objects and/or return handles to objects.
            </summary>
        </member>
        <member name="F:Interop.OBJECT_ATTRIBUTES.RootDirectory">
            <summary>
            Optional handle to root object directory for the given ObjectName.
            Can be a file system directory or object manager directory.
            </summary>
        </member>
        <member name="F:Interop.OBJECT_ATTRIBUTES.ObjectName">
            <summary>
            Name of the object. Must be fully qualified if RootDirectory isn't set.
            Otherwise is relative to RootDirectory.
            </summary>
        </member>
        <member name="F:Interop.OBJECT_ATTRIBUTES.SecurityDescriptor">
            <summary>
            If null, object will receive default security settings.
            </summary>
        </member>
        <member name="F:Interop.OBJECT_ATTRIBUTES.SecurityQualityOfService">
            <summary>
            Optional quality of service to be applied to the object. Used to indicate
            security impersonation level and context tracking mode (dynamic or static).
            </summary>
        </member>
        <member name="M:Interop.OBJECT_ATTRIBUTES.#ctor(Interop.UNICODE_STRING*,Interop.ObjectAttributes,System.IntPtr,Interop.SECURITY_QUALITY_OF_SERVICE*)">
            <summary>
            Equivalent of InitializeObjectAttributes macro with the exception that you can directly set SQOS.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_INHERIT">
            <summary>
            This handle can be inherited by child processes of the current process.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_PERMANENT">
            <summary>
            This flag only applies to objects that are named within the object manager.
            By default, such objects are deleted when all open handles to them are closed.
            If this flag is specified, the object is not deleted when all open handles are closed.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_EXCLUSIVE">
            <summary>
            Only a single handle can be open for this object.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_CASE_INSENSITIVE">
            <summary>
            Lookups for this object should be case insensitive.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_OPENIF">
            <summary>
            Create on existing object should open, not fail with STATUS_OBJECT_NAME_COLLISION.
            </summary>
        </member>
        <member name="F:Interop.ObjectAttributes.OBJ_OPENLINK">
            <summary>
            Open the symbolic link, not its target.
            </summary>
        </member>
        <member name="T:Interop.SECURITY_QUALITY_OF_SERVICE">
            <summary>
            <a href="https://docs.microsoft.com/en-us/windows/win32/api/winnt/ns-winnt-security_quality_of_service">SECURITY_QUALITY_OF_SERVICE</a> structure.
             Used to support client impersonation. Client specifies this to a server to allow
             it to impersonate the client.
            </summary>
        </member>
        <member name="T:Interop.ImpersonationLevel">
            <summary>
            <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa379572.aspx">SECURITY_IMPERSONATION_LEVEL</a> enumeration values.
             [SECURITY_IMPERSONATION_LEVEL]
            </summary>
        </member>
        <member name="F:Interop.ImpersonationLevel.Anonymous">
            <summary>
             The server process cannot obtain identification information about the client and cannot impersonate the client.
             [SecurityAnonymous]
            </summary>
        </member>
        <member name="F:Interop.ImpersonationLevel.Identification">
            <summary>
             The server process can obtain identification information about the client, but cannot impersonate the client.
             [SecurityIdentification]
            </summary>
        </member>
        <member name="F:Interop.ImpersonationLevel.Impersonation">
            <summary>
             The server process can impersonate the client's security context on it's local system.
             [SecurityImpersonation]
            </summary>
        </member>
        <member name="F:Interop.ImpersonationLevel.Delegation">
            <summary>
             The server process can impersonate the client's security context on remote systems.
             [SecurityDelegation]
            </summary>
        </member>
        <member name="T:Interop.ContextTrackingMode">
            <summary>
            <a href="https://msdn.microsoft.com/en-us/library/cc234317.aspx">SECURITY_CONTEXT_TRACKING_MODE</a>
            </summary>
        </member>
        <member name="F:Interop.ContextTrackingMode.Static">
            <summary>
             The server is given a snapshot of the client's security context.
             [SECURITY_STATIC_TRACKING]
            </summary>
        </member>
        <member name="F:Interop.ContextTrackingMode.Dynamic">
            <summary>
             The server is continually updated with changes.
             [SECURITY_DYNAMIC_TRACKING]
            </summary>
        </member>
        <member name="F:Interop.UNICODE_STRING.Length">
            <summary>
            Length in bytes, not including the null terminator, if any.
            </summary>
        </member>
        <member name="F:Interop.UNICODE_STRING.MaximumLength">
            <summary>
            Max size of the buffer in bytes
            </summary>
        </member>
        <member name="M:Interop.Kernel32.CopyFileExPrivate(System.String,System.String,System.IntPtr,System.IntPtr,System.Int32@,System.Int32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use CopyFileEx.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.CreateDirectoryPrivate(System.String,Interop.Kernel32.SECURITY_ATTRIBUTES@)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use CreateDirectory.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.CreateFilePrivate(System.String,System.Int32,System.IO.FileShare,Interop.Kernel32.SECURITY_ATTRIBUTES*,System.IO.FileMode,System.Int32,System.IntPtr)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use CreateFile.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.CreateFilePrivate_IntPtr(System.String,System.Int32,System.IO.FileShare,Interop.Kernel32.SECURITY_ATTRIBUTES*,System.IO.FileMode,System.Int32,System.IntPtr)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use CreateFile.
            </summary>
        </member>
        <member name="F:Interop.Kernel32.SYMBOLIC_LINK_FLAG_DIRECTORY">
            <summary>
            The link target is a directory.
            </summary>
        </member>
        <member name="F:Interop.Kernel32.SYMBOLIC_LINK_FLAG_ALLOW_UNPRIVILEGED_CREATE">
            <summary>
            Allows creation of symbolic links from a process that is not elevated. Requires Windows 10 Insiders build 14972 or later.
            Developer Mode must first be enabled on the machine before this option will function.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.CreateSymbolicLink(System.String,System.String,System.Boolean)">
            <summary>
            Creates a symbolic link.
            </summary>
            <param name="symlinkFileName">The symbolic link to be created.</param>
            <param name="targetFileName">The name of the target for the symbolic link to be created.
            If it has a device name associated with it, the link is treated as an absolute link; otherwise, the link is treated as a relative link.</param>
            <param name="isDirectory"><see langword="true" /> if the link target is a directory; <see langword="false" /> otherwise.</param>
        </member>
        <member name="M:Interop.Kernel32.DeleteFilePrivate(System.String)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use DeleteFile.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.DeleteVolumeMountPointPrivate(System.String)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use DeleteVolumeMountPoint.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.FindFirstFileExPrivate(System.String,Interop.Kernel32.FINDEX_INFO_LEVELS,Interop.Kernel32.WIN32_FIND_DATA@,Interop.Kernel32.FINDEX_SEARCH_OPS,System.IntPtr,System.Int32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use FindFirstFile.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetMessage(System.Int32)">
            <summary>
                Returns a string message for the specified Win32 error code.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetFileAttributesExPrivate(System.String,Interop.Kernel32.GET_FILEEX_INFO_LEVELS,Interop.Kernel32.WIN32_FILE_ATTRIBUTE_DATA@)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use GetFileAttributesEx.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetFullPathNameW(System.Char@,System.UInt32,System.Char@,System.IntPtr)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use GetFullPathName or PathHelper.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.GetLongPathNameW(System.Char@,System.Char@,System.UInt32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use GetFullPath/PathHelper.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.MoveFileExPrivate(System.String,System.String,System.UInt32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use MoveFile.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.MoveFile(System.String,System.String,System.Boolean)">
            <summary>
            Moves a file or directory, optionally overwriting existing destination file. NOTE: overwrite must be false for directories.
            </summary>
            <param name="src">Source file or directory</param>
            <param name="dst">Destination file or directory</param>
            <param name="overwrite">True to overwrite existing destination file. NOTE: must pass false for directories as overwrite of directories is not supported.</param>
            <returns></returns>
        </member>
        <member name="M:Interop.Kernel32.RemoveDirectoryPrivate(System.String)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use RemoveDirectory.
            </summary>
        </member>
        <member name="M:Interop.Kernel32.SetFileAttributesPrivate(System.String,System.Int32)">
            <summary>
            WARNING: This method does not implicitly handle long paths. Use SetFileAttributes.
            </summary>
        </member>
        <member name="T:Interop.NtDll.FILE_FULL_DIR_INFORMATION">
            <summary>
            <a href="https://msdn.microsoft.com/en-us/library/windows/hardware/ff540289.aspx">FILE_FULL_DIR_INFORMATION</a> structure.
            Used with GetFileInformationByHandleEx and FileIdBothDirectoryInfo/RestartInfo as well as NtQueryFileInformation.
            Equivalent to <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/hh447298.aspx">FILE_FULL_DIR_INFO</a> structure.
            </summary>
        </member>
        <member name="F:Interop.NtDll.FILE_FULL_DIR_INFORMATION.NextEntryOffset">
            <summary>
            Offset in bytes of the next entry, if any.
            </summary>
        </member>
        <member name="F:Interop.NtDll.FILE_FULL_DIR_INFORMATION.FileIndex">
            <summary>
            Byte offset within the parent directory, undefined for NTFS.
            </summary>
        </member>
        <member name="F:Interop.NtDll.FILE_FULL_DIR_INFORMATION.FileAttributes">
            <summary>
            File attributes.
            </summary>
            <remarks>
            Note that MSDN documentation isn't correct for this- it can return
            any FILE_ATTRIBUTE that is currently set on the file, not just the
            ones documented.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.FILE_FULL_DIR_INFORMATION.FileNameLength">
            <summary>
            The length of the file name in bytes (without null).
            </summary>
        </member>
        <member name="F:Interop.NtDll.FILE_FULL_DIR_INFORMATION.EaSize">
            <summary>
            The extended attribute size OR the reparse tag if a reparse point.
            </summary>
        </member>
        <member name="M:Interop.NtDll.FILE_FULL_DIR_INFORMATION.GetNextInfo(Interop.NtDll.FILE_FULL_DIR_INFORMATION*)">
            <summary>
            Gets the next info pointer or null if there are no more.
            </summary>
        </member>
        <member name="F:Interop.NtDll.IO_STATUS_BLOCK.Status">
            <summary>
            Status
            </summary>
        </member>
        <member name="F:Interop.NtDll.IO_STATUS_BLOCK.Information">
            <summary>
            Request dependent value.
            </summary>
        </member>
        <member name="F:Interop.NtDll.IO_STATUS_BLOCK.IO_STATUS.Status">
            <summary>
            The completion status, either STATUS_SUCCESS if the operation was completed successfully or
            some other informational, warning, or error status.
            </summary>
        </member>
        <member name="F:Interop.NtDll.IO_STATUS_BLOCK.IO_STATUS.Pointer">
            <summary>
            Reserved for internal use.
            </summary>
        </member>
        <member name="T:Interop.NtDll.CreateDisposition">
            <summary>
            File creation disposition when calling directly to NT APIs.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_SUPERSEDE">
            <summary>
            Default. Replace or create. Deletes existing file instead of overwriting.
            </summary>
            <remarks>
            As this potentially deletes it requires that DesiredAccess must include Delete.
            This has no equivalent in CreateFile.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_OPEN">
            <summary>
            Open if exists or fail if doesn't exist. Equivalent to OPEN_EXISTING or
            <see cref="F:System.IO.FileMode.Open"/>.
            </summary>
            <remarks>
            TruncateExisting also uses Open and then manually truncates the file
            by calling NtSetInformationFile with FileAllocationInformation and an
            allocation size of 0.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_CREATE">
            <summary>
            Create if doesn't exist or fail if does exist. Equivalent to CREATE_NEW
            or <see cref="F:System.IO.FileMode.CreateNew"/>.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_OPEN_IF">
            <summary>
            Open if exists or create if doesn't exist. Equivalent to OPEN_ALWAYS or
            <see cref="F:System.IO.FileMode.OpenOrCreate"/>.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_OVERWRITE">
            <summary>
            Open and overwrite if exists or fail if doesn't exist. Equivalent to
            TRUNCATE_EXISTING or <see cref="F:System.IO.FileMode.Truncate"/>.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateDisposition.FILE_OVERWRITE_IF">
            <summary>
            Open and overwrite if exists or create if doesn't exist. Equivalent to
            CREATE_ALWAYS or <see cref="F:System.IO.FileMode.Create"/>.
            </summary>
        </member>
        <member name="T:Interop.NtDll.CreateOptions">
            <summary>
            Options for creating/opening files with NtCreateFile.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_DIRECTORY_FILE">
            <summary>
            File being created or opened must be a directory file. Disposition must be FILE_CREATE, FILE_OPEN,
            or FILE_OPEN_IF.
            </summary>
            <remarks>
            Can only be used with FILE_SYNCHRONOUS_IO_ALERT/NONALERT, FILE_WRITE_THROUGH, FILE_OPEN_FOR_BACKUP_INTENT,
            and FILE_OPEN_BY_FILE_ID flags.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_WRITE_THROUGH">
            <summary>
            Applications that write data to the file must actually transfer the data into
            the file before any requested write operation is considered complete. This flag
            is set automatically if FILE_NO_INTERMEDIATE_BUFFERING is set.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_SEQUENTIAL_ONLY">
            <summary>
            All accesses to the file are sequential.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_NO_INTERMEDIATE_BUFFERING">
            <summary>
            File cannot be cached in driver buffers. Cannot use with AppendData desired access.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_SYNCHRONOUS_IO_ALERT">
            <summary>
            All operations are performed synchronously. Any wait on behalf of the caller is
            subject to premature termination from alerts.
            </summary>
            <remarks>
            Cannot be used with FILE_SYNCHRONOUS_IO_NONALERT.
            Synchronous DesiredAccess flag is required. I/O system will maintain file position context.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_SYNCHRONOUS_IO_NONALERT">
            <summary>
            All operations are performed synchronously. Waits in the system to synchronize I/O queuing
            and completion are not subject to alerts.
            </summary>
            <remarks>
            Cannot be used with FILE_SYNCHRONOUS_IO_ALERT.
            Synchronous DesiredAccess flag is required. I/O system will maintain file position context.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_NON_DIRECTORY_FILE">
            <summary>
            File being created or opened must not be a directory file. Can be a data file, device,
            or volume.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_CREATE_TREE_CONNECTION">
            <summary>
            Create a tree connection for this file in order to open it over the network.
            </summary>
            <remarks>
            Not used by device and intermediate drivers.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_COMPLETE_IF_OPLOCKED">
            <summary>
            Complete the operation immediately with a success code of STATUS_OPLOCK_BREAK_IN_PROGRESS if
            the target file is oplocked.
            </summary>
            <remarks>
            Not compatible with ReserveOpfilter or OpenRequiringOplock.
            Not used by device and intermediate drivers.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_NO_EA_KNOWLEDGE">
            <summary>
            If the extended attributes on an existing file being opened indicate that the caller must
            understand extended attributes to properly interpret the file, fail the request.
            </summary>
            <remarks>
            Not used by device and intermediate drivers.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_RANDOM_ACCESS">
            <summary>
            Accesses to the file can be random, so no sequential read-ahead operations should be performed
            on the file by FSDs or the system.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_DELETE_ON_CLOSE">
            <summary>
            Delete the file when the last handle to it is passed to NtClose. Requires Delete flag in
            DesiredAccess parameter.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_OPEN_BY_FILE_ID">
            <summary>
            Open the file by reference number or object ID. The file name that is specified by the ObjectAttributes
            name parameter includes the 8 or 16 byte file reference number or ID for the file in the ObjectAttributes
            name field. The device name can optionally be prefixed.
            </summary>
            <remarks>
            NTFS supports both reference numbers and object IDs. 16 byte reference numbers are 8 byte numbers padded
            with zeros. ReFS only supports reference numbers (not object IDs). 8 byte and 16 byte reference numbers
            are not related. Note that as the UNICODE_STRING will contain raw byte data, it may not be a "valid" string.
            Not used by device and intermediate drivers.
            </remarks>
            <example>
            \??\C:\{8 bytes of binary FileID}
            \device\HardDiskVolume1\{16 bytes of binary ObjectID}
            {8 bytes of binary FileID}
            </example>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_OPEN_FOR_BACKUP_INTENT">
            <summary>
            The file is being opened for backup intent. Therefore, the system should check for certain access rights
            and grant the caller the appropriate access to the file before checking the DesiredAccess parameter
            against the file's security descriptor.
            </summary>
            <remarks>
            Not used by device and intermediate drivers.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_NO_COMPRESSION">
            <summary>
            When creating a file, specifies that it should not inherit the compression bit from the parent directory.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_OPEN_REQUIRING_OPLOCK">
            <summary>
            The file is being opened and an opportunistic lock (oplock) on the file is being requested as a single atomic
            operation.
            </summary>
            <remarks>
            The file system checks for oplocks before it performs the create operation and will fail the create with a
            return code of STATUS_CANNOT_BREAK_OPLOCK if the result would be to break an existing oplock.
            Not compatible with CompleteIfOplocked or ReserveOpFilter. Windows 7 and up.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_DISALLOW_EXCLUSIVE">
            <summary>
            CreateFile2 uses this flag to prevent opening a file that you don't have access to without specifying
            FILE_SHARE_READ. (Preventing users that can only read a file from denying access to other readers.)
            </summary>
            <remarks>
            Windows 7 and up.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_SESSION_AWARE">
            <summary>
            The client opening the file or device is session aware and per session access is validated if necessary.
            </summary>
            <remarks>
            Windows 8 and up.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_RESERVE_OPFILTER">
            <summary>
            This flag allows an application to request a filter opportunistic lock (oplock) to prevent other applications
            from getting share violations.
            </summary>
            <remarks>
            Not compatible with CompleteIfOplocked or OpenRequiringOplock.
            If there are already open handles, the create request will fail with STATUS_OPLOCK_NOT_GRANTED.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_OPEN_REPARSE_POINT">
            <summary>
            Open a file with a reparse point attribute, bypassing the normal reparse point processing.
            </summary>
        </member>
        <member name="F:Interop.NtDll.CreateOptions.FILE_OPEN_NO_RECALL">
            <summary>
            Causes files that are marked with the Offline attribute not to be recalled from remote storage.
            </summary>
            <remarks>
            More details can be found in Remote Storage documentation (see Basic Concepts).
            https://technet.microsoft.com/en-us/library/cc938459.aspx
            </remarks>
        </member>
        <member name="T:Interop.NtDll.DesiredAccess">
            <summary>
            System.IO.FileAccess looks up these values when creating handles
            </summary>
            <remarks>
            File Security and Access Rights
            https://msdn.microsoft.com/en-us/library/windows/desktop/aa364399.aspx
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_READ_DATA">
            <summary>
            For a file, the right to read data from the file.
            </summary>
            <remarks>
            Directory version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_LIST_DIRECTORY"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_LIST_DIRECTORY">
            <summary>
            For a directory, the right to list the contents.
            </summary>
            <remarks>
            File version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_DATA"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_WRITE_DATA">
            <summary>
            For a file, the right to write data to the file.
            </summary>
            <remarks>
            Directory version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_ADD_FILE"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_ADD_FILE">
            <summary>
            For a directory, the right to create a file in a directory.
            </summary>
            <remarks>
            File version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_DATA"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_APPEND_DATA">
            <summary>
            For a file, the right to append data to a file. <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_DATA"/> is needed
            to overwrite existing data.
            </summary>
            <remarks>
            Directory version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_ADD_SUBDIRECTORY"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_ADD_SUBDIRECTORY">
            <summary>
            For a directory, the right to create a subdirectory.
            </summary>
            <remarks>
            File version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_APPEND_DATA"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_CREATE_PIPE_INSTANCE">
            <summary>
            For a named pipe, the right to create a pipe instance.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_READ_EA">
            <summary>
            The right to read extended attributes.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_WRITE_EA">
            <summary>
            The right to write extended attributes.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_EXECUTE">
            <summary>
            The right to execute the file.
            </summary>
            <remarks>
            Directory version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_TRAVERSE"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_TRAVERSE">
            <summary>
            For a directory, the right to traverse the directory.
            </summary>
            <remarks>
            File version of this flag is <see cref="F:Interop.NtDll.DesiredAccess.FILE_EXECUTE"/>.
            </remarks>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_DELETE_CHILD">
            <summary>
            For a directory, the right to delete a directory and all
            the files it contains, including read-only files.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_READ_ATTRIBUTES">
            <summary>
            The right to read attributes.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_WRITE_ATTRIBUTES">
            <summary>
            The right to write attributes.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_ALL_ACCESS">
            <summary>
            All standard and specific rights. [FILE_ALL_ACCESS]
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.DELETE">
            <summary>
            The right to delete the object.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.READ_CONTROL">
            <summary>
            The right to read the information in the object's security descriptor.
            Doesn't include system access control list info (SACL).
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.WRITE_DAC">
            <summary>
            The right to modify the discretionary access control list (DACL) in the
            object's security descriptor.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.WRITE_OWNER">
            <summary>
            The right to change the owner in the object's security descriptor.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE">
            <summary>
            The right to use the object for synchronization. Enables a thread to wait until the object
            is in the signaled state. This is required if opening a synchronous handle.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_READ">
            <summary>
            Same as READ_CONTROL.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_WRITE">
            <summary>
            Same as READ_CONTROL.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_EXECUTE">
            <summary>
            Same as READ_CONTROL.
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_GENERIC_READ">
            <summary>
            Maps internally to <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_DATA"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_EA"/>
            | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_READ"/> | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.
            (For directories, <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_LIST_DIRECTORY"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_EA"/>
            | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_READ"/> | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.)
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_GENERIC_WRITE">
            <summary>
            Maps internally to <see cref="F:Interop.NtDll.DesiredAccess.FILE_APPEND_DATA"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_DATA"/>
            | <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_EA"/> | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_READ"/> | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.
            (For directories, <see cref="F:Interop.NtDll.DesiredAccess.FILE_ADD_SUBDIRECTORY"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_ADD_FILE"/> AddFile
            | <see cref="F:Interop.NtDll.DesiredAccess.FILE_WRITE_EA"/> | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_READ"/> | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.)
            </summary>
        </member>
        <member name="F:Interop.NtDll.DesiredAccess.FILE_GENERIC_EXECUTE">
            <summary>
            Maps internally to <see cref="F:Interop.NtDll.DesiredAccess.FILE_EXECUTE"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_EXECUTE"/>
            | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.
            (For directories, <see cref="F:Interop.NtDll.DesiredAccess.FILE_DELETE_CHILD"/> | <see cref="F:Interop.NtDll.DesiredAccess.FILE_READ_ATTRIBUTES"/> | <see cref="F:Interop.NtDll.DesiredAccess.STANDARD_RIGHTS_EXECUTE"/>
            | <see cref="F:Interop.NtDll.DesiredAccess.SYNCHRONIZE"/>.)
            </summary>
        </member>
        <member name="M:Microsoft.IO.Directory.CreateSymbolicLink(System.String,System.String)">
            <summary>
            Creates a directory symbolic link identified by <paramref name="path"/> that points to <paramref name="pathToTarget"/>.
            </summary>
            <param name="path">The absolute path where the symbolic link should be created.</param>
            <param name="pathToTarget">The target directory of the symbolic link.</param>
            <returns>A <see cref="T:Microsoft.IO.DirectoryInfo"/> instance that wraps the newly created directory symbolic link.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> or <paramref name="pathToTarget"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> or <paramref name="pathToTarget"/> is empty.
            -or-
            <paramref name="path"/> is not an absolute path.
            -or-
            <paramref name="path"/> or <paramref name="pathToTarget"/> contains invalid path characters.</exception>
            <exception cref="T:System.IO.IOException">A file or directory already exists in the location of <paramref name="path"/>.
            -or-
            An I/O error occurred.</exception>
        </member>
        <member name="M:Microsoft.IO.Directory.ResolveLinkTarget(System.String,System.Boolean)">
            <summary>
            Gets the target of the specified directory link.
            </summary>
            <param name="linkPath">The path of the directory link.</param>
            <param name="returnFinalTarget"><see langword="true"/> to follow links to the final target; <see langword="false"/> to return the immediate next link.</param>
            <returns>A <see cref="T:Microsoft.IO.DirectoryInfo"/> instance if <paramref name="linkPath"/> exists, independently if the target exists or not. <see langword="null"/> if <paramref name="linkPath"/> is not a link.</returns>
            <exception cref="T:System.IO.IOException">The directory on <paramref name="linkPath"/> does not exist.
            -or-
            The link's file system entry type is inconsistent with that of its target.
            -or-
            Too many levels of symbolic links.</exception>
            <remarks>When <paramref name="returnFinalTarget"/> is <see langword="true"/>, the maximum number of symbolic links that are followed are 40 on Unix and 63 on Windows.</remarks>
        </member>
        <member name="T:Microsoft.IO.DisableMediaInsertionPrompt">
            <summary>
            Simple wrapper to safely disable the normal media insertion prompt for
            removable media (floppies, cds, memory cards, etc.)
            </summary>
            <remarks>
            Note that removable media file systems lazily load. After starting the OS
            they won't be loaded until you have media in the drive- and as such the
            prompt won't happen. You have to have had media in at least once to get
            the file system to load and then have removed it.
            </remarks>
        </member>
        <member name="T:Microsoft.IO.EnumerationOptions">
            <summary>Provides file and directory enumeration options.</summary>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.Compatible">
            <summary>
            For internal use. These are the options we want to use if calling the existing Directory/File APIs where you don't
            explicitly specify EnumerationOptions.
            </summary>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.Default">
            <summary>
            Internal singleton for default options.
            </summary>
        </member>
        <member name="M:Microsoft.IO.EnumerationOptions.#ctor">
            <summary>Initializes a new instance of the <see cref="T:Microsoft.IO.EnumerationOptions" /> class with the recommended default options.</summary>
        </member>
        <member name="M:Microsoft.IO.EnumerationOptions.FromSearchOption(Microsoft.IO.SearchOption)">
            <summary>
            Converts SearchOptions to FindOptions. Throws if undefined SearchOption.
            </summary>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.RecurseSubdirectories">
            <summary>Gets or sets a value that indicates whether to recurse into subdirectories while enumerating. The default is <see langword="false" />.</summary>
            <value><see langword="true" /> to recurse into subdirectories; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.IgnoreInaccessible">
            <summary>Gets or sets a value that indicates whether to skip files or directories when access is denied (for example, <see cref="T:System.UnauthorizedAccessException" /> or <see cref="T:System.Security.SecurityException" />). The default is <see langword="true" />.</summary>
            <value><see langword="true" /> to skip innacessible files or directories; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.BufferSize">
            <summary>Gets or sets the suggested buffer size, in bytes. The default is 0 (no suggestion).</summary>
            <value>The buffer size.</value>
            <remarks>Not all platforms use user allocated buffers, and some require either fixed buffers or a buffer that has enough space to return a full result.
            One scenario where this option is useful is with remote share enumeration on Windows. Having a large buffer may result in better performance as more results can be batched over the wire (for example, over a network share).
            A "large" buffer, for example, would be 16K. Typical is 4K.
            The suggested buffer size will not be used if it has no meaning for the native APIs on the current platform or if it would be too small for getting at least a single result.</remarks>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.AttributesToSkip">
            <summary>Gets or sets the attributes to skip. The default is <c>FileAttributes.Hidden | FileAttributes.System</c>.</summary>
            <value>The attributes to skip.</value>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.MatchType">
            <summary>Gets or sets the match type.</summary>
            <value>One of the enumeration values that indicates the match type.</value>
            <remarks>For APIs that allow specifying a match expression, this property allows you to specify how to interpret the match expression.
            The default is simple matching where '*' is always 0 or more characters and '?' is a single character.</remarks>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.MatchCasing">
            <summary>Gets or sets the case matching behavior.</summary>
            <value>One of the enumeration values that indicates the case matching behavior.</value>
            <remarks>For APIs that allow specifying a match expression, this property allows you to specify the case matching behavior.
            The default is to match platform defaults, which are gleaned from the case sensitivity of the temporary folder.</remarks>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.MaxRecursionDepth">
            <summary>Gets or sets a value that indicates the maximum directory depth to recurse while enumerating, when <see cref="P:Microsoft.IO.EnumerationOptions.RecurseSubdirectories" /> is set to <see langword="true" />.</summary>
            <value>A number that represents the maximum directory depth to recurse while enumerating. The default value is <see cref="F:System.Int32.MaxValue" />.</value>
            <remarks>If <see cref="P:Microsoft.IO.EnumerationOptions.MaxRecursionDepth" /> is set to a negative number, the default value <see cref="F:System.Int32.MaxValue" /> is used.
            If <see cref="P:Microsoft.IO.EnumerationOptions.MaxRecursionDepth" /> is set to zero, enumeration returns the contents of the initial directory.</remarks>
        </member>
        <member name="P:Microsoft.IO.EnumerationOptions.ReturnSpecialDirectories">
            <summary>Gets or sets a value that indicates whether to return the special directory entries "." and "..".</summary>
            <value><see langword="true" /> to return the special directory entries "." and ".."; otherwise, <see langword="false" />.</value>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemEntry">
            <summary>Provides a lower level view of <see cref="T:System.IO.FileSystemInfo" /> to help process and filter find results.</summary>
            <summary>Provides a lower level view of <see cref="T:System.IO.FileSystemInfo" /> to help process and filter find results.</summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEntry.ToSpecifiedFullPath">
            <summary>Returns the full path for the find results, based on the initially provided path.</summary>
            <returns>A string representing the full path.</returns>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.Directory">
            <summary>Gets the full path of the directory this entry resides in.</summary>
            <value>The full path of this entry's directory.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.RootDirectory">
            <summary>Gets the full path of the root directory used for the enumeration.</summary>
            <value>The root directory.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.OriginalRootDirectory">
            <summary>Gets the root directory for the enumeration as specified in the constructor.</summary>
            <value>The original root directory.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.FileName">
            <summary>Gets the file name for this entry.</summary>
            <value>This entry's file name.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.Attributes">
            <summary>Gets the attributes for this entry.</summary>
            <value>The attributes for this entry.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.Length">
            <summary>Gets the length of the file, in bytes.</summary>
            <value>The file length in bytes.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.CreationTimeUtc">
            <summary>Gets the creation time for the entry or the oldest available time stamp if the operating system does not support creation time stamps.</summary>
            <value>The creation time for the entry.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.LastAccessTimeUtc">
            <summary>Gets a datetime offset that represents the last access time in UTC.</summary>
            <value>The last access time in UTC.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.LastWriteTimeUtc">
            <summary>Gets a datetime offset that represents the last write time in UTC.</summary>
            <value>The last write time in UTC.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.IsDirectory">
            <summary>Gets a value that indicates whether this entry is a directory.</summary>
            <value><see langword="true" /> if the entry is a directory; otherwise, <see langword="false" />.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEntry.IsHidden">
            <summary>Gets a value that indicates whether the file has the hidden attribute.</summary>
            <value><see langword="true" /> if the file has the hidden attribute; otherwise, <see langword="false" />.</value>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEntry.ToFileSystemInfo">
            <summary>Converts the value of this instance to a <see cref="T:System.IO.FileSystemInfo" />.</summary>
            <returns>The value of this instance as a <see cref="T:System.IO.FileSystemInfo" />.</returns>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEntry.ToFullPath">
            <summary>Returns the full path of the find result.</summary>
            <returns>A string representing the full path.</returns>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemEnumerable`1">
            <summary>
            Enumerable that allows utilizing custom filter predicates and tranform delegates.
            </summary>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemEnumerable`1.FindPredicate">
            <summary>
            Delegate for filtering out find results.
            </summary>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemEnumerable`1.FindTransform">
            <summary>
            Delegate for transforming raw find data into a result.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerableFactory.NormalizeInputs(System.String@,System.String@,Microsoft.IO.MatchType)">
            <summary>
            Validates the directory and expression strings to check that they have no invalid characters, any special DOS wildcard characters in Win32 in the expression get replaced with their proper escaped representation, and if the expression string begins with a directory name, the directory name is moved and appended at the end of the directory string.
            </summary>
            <param name="directory">A reference to a directory string that we will be checking for normalization.</param>
            <param name="expression">A reference to a expression string that we will be checking for normalization.</param>
            <param name="matchType">The kind of matching we want to check in the expression. If the value is Win32, we will replace special DOS wild characters to their safely escaped representation. This replacement does not affect the normalization status of the expression.</param>
            <returns><cref langword="false" /> if the directory reference string get modified inside this function due to the expression beginning with a directory name. <cref langword="true" /> if the directory reference string was not modified.</returns>
            <exception cref="T:System.ArgumentException">
            The expression is a rooted path.
            -or-
            The directory or the expression reference strings contain a null character.
            </exception>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The match type is out of the range of the valid MatchType enum values.
            </exception>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemEnumerator`1">
            <summary>Enumerates the file system elements of the provided type that are being searched and filtered by a <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerable`1" />.</summary>
            <typeparam name="TResult">The type of the result produced by this file system enumerator.</typeparam>
            <summary>Enumerates the file system elements of the provided type that are being searched and filtered by a <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerable`1" />.</summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.#ctor(System.String,Microsoft.IO.EnumerationOptions)">
            <summary>Encapsulates a find operation.</summary>
            <param name="directory">The directory to search in.</param>
            <param name="options">Enumeration options to use.</param>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.#ctor(System.String,System.Boolean,Microsoft.IO.EnumerationOptions)">
            <summary>
            Encapsulates a find operation.
            </summary>
            <param name="directory">The directory to search in.</param>
            <param name="isNormalized">Whether the directory path is already normalized or not.</param>
            <param name="options">Enumeration options to use.</param>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.ShouldIncludeEntry(Microsoft.IO.Enumeration.FileSystemEntry@)">
            <summary>When overridden in a derived class, determines whether the specified file system entry should be included in the results.</summary>
            <param name="entry">A file system entry reference.</param>
            <returns><see langword="true" /> if the specified file system entry should be included in the results; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.ShouldRecurseIntoEntry(Microsoft.IO.Enumeration.FileSystemEntry@)">
            <summary>When overridden in a derived class, determines whether the specified file system entry should be recursed.</summary>
            <param name="entry">A file system entry reference.</param>
            <returns><see langword="true" /> if the specified directory entry should be recursed into; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.TransformEntry(Microsoft.IO.Enumeration.FileSystemEntry@)">
            <summary>When overridden in a derived class, generates the result type from the current entry.</summary>
            <param name="entry">A file system entry reference.</param>
            <returns>The result type from the current entry.</returns>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.OnDirectoryFinished(System.ReadOnlySpan{System.Char})">
            <summary>When overridden in a derived class, this method is called whenever the end of a directory is reached.</summary>
            <param name="directory">The directory path as a read-only span.</param>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.ContinueOnError(System.Int32)">
            <summary>When overridden in a derived class, returns a value that indicates whether to continue execution or throw the default exception.</summary>
            <param name="error">The native error code.</param>
            <returns><see langword="true" /> to continue; <see langword="false" /> to throw the default exception for the given error.</returns>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEnumerator`1.Current">
            <summary>Gets the currently visited element.</summary>
            <value>The currently visited element.</value>
        </member>
        <member name="P:Microsoft.IO.Enumeration.FileSystemEnumerator`1.System#Collections#IEnumerator#Current">
            <summary>Gets the currently visited object.</summary>
            <value>The currently visited object.</value>
            <remarks>This member is an explicit interface member implementation. It can be used only when the <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerator`1" /> instance is cast to an <see cref="T:System.Collections.IEnumerator" /> interface.</remarks>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.Reset">
            <summary>Always throws <see cref="T:System.NotSupportedException" />.</summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.Dispose">
            <summary>Releases the resources used by the current instance of the <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerator`1" /> class.</summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.Dispose(System.Boolean)">
            <summary>When overridden in a derived class, releases the unmanaged resources used by the <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerator`1" /> class and optionally releases the managed resources.</summary>
            <param name="disposing"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</param>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.GetData">
            <summary>
            Fills the buffer with the next set of data.
            </summary>
            <returns>'true' if new data was found</returns>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.CreateDirectoryHandle(System.String,System.Boolean)">
            <summary>
            Simple wrapper to allow creating a file handle for an existing directory.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemEnumerator`1.MoveNext">
            <summary>Advances the enumerator to the next item of the <see cref="T:Microsoft.IO.Enumeration.FileSystemEnumerator`1" />.</summary>
            <returns><see langword="true" /> if the enumerator successfully advanced to the next item; <see langword="false" /> if the end of the enumerator has been passed.</returns>
        </member>
        <member name="T:Microsoft.IO.Enumeration.FileSystemName">
            <summary>Provides methods for matching file system names.</summary>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemName.TranslateWin32Expression(System.String)">
            <summary>Translates the given Win32 expression. Change '*' and '?' to '&lt;', '&gt;' and '"' to match Win32 behavior.</summary>
            <param name="expression">The expression to translate.</param>
            <returns>A string with the translated Win32 expression.</returns>
            <remarks>For compatibility, Windows changes some wildcards to provide a closer match to historical DOS 8.3 filename matching.</remarks>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemName.MatchesWin32Expression(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>Verifies whether the given Win32 expression matches the given name. Supports the following wildcards: '*', '?', '&lt;', '&gt;', '"'. The backslash character '\' escapes.</summary>
            <param name="expression">The expression to match with, such as "*.foo".</param>
            <param name="name">The name to check against the expression.</param>
            <param name="ignoreCase"><see langword="true" /> to ignore case (default), <see langword="false" /> if the match should be case-sensitive.</param>
            <returns><see langword="true" /> if the given expression matches the given name; otherwise, <see langword="false" />.</returns>
            <remarks>The syntax of the <paramref name="expression" /> parameter is based on the syntax used by FileSystemWatcher, which is based on [RtlIsNameInExpression](/windows/win32/devnotes/rtlisnameinexpression), which defines the rules for matching DOS wildcards (`'*'`, `'?'`, `'&lt;'`, `'&gt;'`, `'"'`).
            Matching will not correspond to Win32 behavior unless you transform the expression using <see cref="M:Microsoft.IO.Enumeration.FileSystemName.TranslateWin32Expression(System.String)" />.</remarks>
        </member>
        <member name="M:Microsoft.IO.Enumeration.FileSystemName.MatchesSimpleExpression(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char},System.Boolean)">
            <summary>Verifies whether the given expression matches the given name. Supports the following wildcards: '*' and '?'. The backslash character '\\' escapes.</summary>
            <param name="expression">The expression to match with.</param>
            <param name="name">The name to check against the expression.</param>
            <param name="ignoreCase"><see langword="true" /> to ignore case (default); <see langword="false" /> if the match should be case-sensitive.</param>
            <returns><see langword="true" /> if the given expression matches the given name; otherwise, <see langword="false" />.</returns>
        </member>
        <member name="M:Microsoft.IO.File.Copy(System.String,System.String)">
            <summary>
            Copies an existing file to a new file.
            An exception is raised if the destination file already exists.
            </summary>
        </member>
        <member name="M:Microsoft.IO.File.Copy(System.String,System.String,System.Boolean)">
            <summary>
            Copies an existing file to a new file.
            If <paramref name="overwrite"/> is false, an exception will be
            raised if the destination exists. Otherwise it will be overwritten.
            </summary>
        </member>
        <member name="M:Microsoft.IO.File.CreateSymbolicLink(System.String,System.String)">
            <summary>
            Creates a file symbolic link identified by <paramref name="path"/> that points to <paramref name="pathToTarget"/>.
            </summary>
            <param name="path">The path where the symbolic link should be created.</param>
            <param name="pathToTarget">The path of the target to which the symbolic link points.</param>
            <returns>A <see cref="T:Microsoft.IO.FileInfo"/> instance that wraps the newly created file symbolic link.</returns>
            <exception cref="T:System.ArgumentNullException"><paramref name="path"/> or <paramref name="pathToTarget"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="path"/> or <paramref name="pathToTarget"/> is empty.
            -or-
            <paramref name="path"/> or <paramref name="pathToTarget"/> contains a null character.</exception>
            <exception cref="T:System.IO.IOException">A file or directory already exists in the location of <paramref name="path"/>.
            -or-
            An I/O error occurred.</exception>
        </member>
        <member name="M:Microsoft.IO.File.ResolveLinkTarget(System.String,System.Boolean)">
            <summary>
            Gets the target of the specified file link.
            </summary>
            <param name="linkPath">The path of the file link.</param>
            <param name="returnFinalTarget"><see langword="true"/> to follow links to the final target; <see langword="false"/> to return the immediate next link.</param>
            <returns>A <see cref="T:Microsoft.IO.FileInfo"/> instance if <paramref name="linkPath"/> exists, independently if the target exists or not. <see langword="null"/> if <paramref name="linkPath"/> is not a link.</returns>
            <exception cref="T:System.IO.IOException">The file on <paramref name="linkPath"/> does not exist.
            -or-
            The link's file system entry type is inconsistent with that of its target.
            -or-
            Too many levels of symbolic links.</exception>
            <remarks>When <paramref name="returnFinalTarget"/> is <see langword="true"/>, the maximum number of symbolic links that are followed are 40 on Unix and 63 on Windows.</remarks>
        </member>
        <member name="M:Microsoft.IO.FileSystem.FillAttributeInfo(System.String,Interop.Kernel32.WIN32_FILE_ATTRIBUTE_DATA@,System.Boolean)">
            <summary>
            Returns 0 on success, otherwise a Win32 error code.  Note that
            classes should use -1 as the uninitialized state for dataInitialized.
            </summary>
            <param name="path">The file path from which the file attribute information will be filled.</param>
            <param name="data">A struct that will contain the attribute information.</param>
            <param name="returnErrorOnNotFound">Return the error code for not found errors?</param>
        </member>
        <member name="M:Microsoft.IO.FileSystem.GetImmediateLinkTarget(System.String,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets reparse point information associated to <paramref name="linkPath"/>.
            </summary>
            <returns>The immediate link target, absolute or relative or null if the file is not a supported link.</returns>
        </member>
        <member name="P:Microsoft.IO.FileSystemInfo.LinkTarget">
            <summary>
            If this <see cref="T:Microsoft.IO.FileSystemInfo"/> instance represents a link, returns the link target's path.
            If a link does not exist in <see cref="P:Microsoft.IO.FileSystemInfo.FullName"/>, or this instance does not represent a link, returns <see langword="null"/>.
            </summary>
        </member>
        <member name="M:Microsoft.IO.FileSystemInfo.CreateAsSymbolicLink(System.String)">
            <summary>
            Creates a symbolic link located in <see cref="P:Microsoft.IO.FileSystemInfo.FullName"/> that points to the specified <paramref name="pathToTarget"/>.
            </summary>
            <param name="pathToTarget">The path of the symbolic link target.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="pathToTarget"/> is <see langword="null"/>.</exception>
            <exception cref="T:System.ArgumentException"><paramref name="pathToTarget"/> is empty.
            -or-
            This instance was not created passing an absolute path.
            -or-
            <paramref name="pathToTarget"/> contains invalid path characters.</exception>
            <exception cref="T:System.IO.IOException">A file or directory already exists in the location of <see cref="P:Microsoft.IO.FileSystemInfo.FullName"/>.
            -or-
            An I/O error occurred.</exception>
        </member>
        <member name="M:Microsoft.IO.FileSystemInfo.ResolveLinkTarget(System.Boolean)">
            <summary>
            Gets the target of the specified link.
            </summary>
            <param name="returnFinalTarget"><see langword="true"/> to follow links to the final target; <see langword="false"/> to return the immediate next link.</param>
            <returns>A <see cref="T:Microsoft.IO.FileSystemInfo"/> instance if the link exists, independently if the target exists or not; <see langword="null"/> if this file or directory is not a link.</returns>
            <exception cref="T:System.IO.IOException">The file or directory does not exist.
            -or-
            The link's file system entry type is inconsistent with that of its target.
            -or-
            Too many levels of symbolic links.</exception>
            <remarks>When <paramref name="returnFinalTarget"/> is <see langword="true"/>, the maximum number of symbolic links that are followed are 40 on Unix and 63 on Windows.</remarks>
        </member>
        <member name="M:Microsoft.IO.FileSystemInfo.ToString">
            <summary>
            Returns the original path. Use FullName or Name properties for the full path or file/directory name.
            </summary>
        </member>
        <member name="T:Microsoft.IO.MatchCasing">
            <summary>Specifies the type of character casing to match.</summary>
        </member>
        <member name="F:Microsoft.IO.MatchCasing.PlatformDefault">
            <summary>Matches using the default casing for the given platform.</summary>
        </member>
        <member name="F:Microsoft.IO.MatchCasing.CaseSensitive">
            <summary>Matches respecting character casing.</summary>
        </member>
        <member name="F:Microsoft.IO.MatchCasing.CaseInsensitive">
            <summary>Matches ignoring character casing.</summary>
        </member>
        <member name="T:Microsoft.IO.MatchType">
            <summary>Specifies the type of wildcard matching to use.</summary>
        </member>
        <member name="F:Microsoft.IO.MatchType.Simple">
            <summary><para>Matches using '*' and '?' wildcards.</para><para>
            <c>*</c> matches from zero to any amount of characters. <c>?</c> matches exactly one character. <c>*.*</c> matches any name with a period in it (with <see cref="F:Microsoft.IO.MatchType.Win32" />, this would match all items).</para></summary>
        </member>
        <member name="F:Microsoft.IO.MatchType.Win32">
            <summary><para>Match using Win32 DOS style matching semantics.</para><para>'*', '?', '&lt;', '&gt;', and '"' are all considered wildcards. Matches in a traditional DOS <c>/</c> Windows command prompt way. <c>*.*</c> matches all files. <c>?</c> matches collapse to periods. <c>file.??t</c> will match <c>file.t</c>, <c>file.at</c>, and <c>file.txt</c>.</para></summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetDirectoryName(System.String)">
            <summary>
            Returns the directory portion of a file path. This method effectively
            removes the last segment of the given file path, i.e. it returns a
            string consisting of all characters up to but not including the last
            backslash ("\") in the file path. The returned value is null if the
            specified path is null, empty, or a root (such as "\", "C:", or
            "\\server\share").
            </summary>
            <remarks>
            Directory separators are normalized in the returned string.
            </remarks>
        </member>
        <member name="M:Microsoft.IO.Path.GetDirectoryName(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the directory portion of a file path. The returned value is empty
            if the specified path is null, empty, or a root (such as "\", "C:", or
            "\\server\share").
            </summary>
            <remarks>
            Unlike the string overload, this method will not normalize directory separators.
            </remarks>
        </member>
        <member name="M:Microsoft.IO.Path.GetExtension(System.String)">
            <summary>
            Returns the extension of the given path. The returned value includes the period (".") character of the
            extension except when you have a terminal period when you get string.Empty, such as ".exe" or ".cpp".
            The returned value is null if the given path is null or empty if the given path does not include an
            extension.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetExtension(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the extension of the given path.
            </summary>
            <remarks>
            The returned value is an empty ReadOnlySpan if the given path does not include an extension.
            </remarks>
        </member>
        <member name="M:Microsoft.IO.Path.GetFileName(System.String)">
            <summary>
            Returns the name and extension parts of the given path. The resulting string contains
            the characters of path that follow the last separator in path. The resulting string is
            null if path is null.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetFileName(System.ReadOnlySpan{System.Char})">
            <summary>
            The returned ReadOnlySpan contains the characters of the path that follows the last separator in path.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetFileNameWithoutExtension(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the characters between the last separator and last (.) in the path.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetRandomFileName">
            <summary>
            Returns a cryptographically strong random 8.3 string that can be
            used as either a folder name or a file name.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.IsPathFullyQualified(System.String)">
            <summary>
            Returns true if the path is fixed to a specific drive or UNC path. This method does no
            validation of the path (URIs will be returned as relative as a result).
            Returns false if the path specified is relative to the current drive or working directory.
            </summary>
            <remarks>
            Handles paths that use the alternate directory separator.  It is a frequent mistake to
            assume that rooted paths <see cref="M:Microsoft.IO.Path.IsPathRooted(System.String)"/> are not relative.  This isn't the case.
            "C:a" is drive relative- meaning that it will be resolved against the current directory
            for C: (rooted, but relative). "C:\a" is rooted and not relative (the current directory
            will not be used to modify the path).
            </remarks>
            <exception cref="T:System.ArgumentNullException">
            Thrown if <paramref name="path"/> is null.
            </exception>
        </member>
        <member name="M:Microsoft.IO.Path.HasExtension(System.String)">
            <summary>
            Tests if a path's file name includes a file extension. A trailing period
            is not considered an extension.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetRelativePath(System.String,System.String)">
            <summary>
            Create a relative path from one path to another. Paths will be resolved before calculating the difference.
            Default path comparison for the active platform will be used (OrdinalIgnoreCase for Windows or Mac, Ordinal for Unix).
            </summary>
            <param name="relativeTo">The source path the output should be relative to. This path is always considered to be a directory.</param>
            <param name="path">The destination path.</param>
            <returns>The relative path or <paramref name="path"/> if the paths don't share the same root.</returns>
            <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="relativeTo"/> or <paramref name="path"/> is <c>null</c> or an empty string.</exception>
        </member>
        <member name="M:Microsoft.IO.Path.TrimEndingDirectorySeparator(System.String)">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.EndsInDirectorySeparator(System.String)">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetPathRoot(System.ReadOnlySpan{System.Char})">
            <remarks>
            Unlike the string overload, this method will not normalize directory separators.
            </remarks>
        </member>
        <member name="M:Microsoft.IO.Path.GetVolumeName(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns the volume name for dos, UNC and device paths.
            </summary>
        </member>
        <member name="M:Microsoft.IO.Path.GetUncRootLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns offset as -1 if the path is not in Unc format, otherwise returns the root length.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.IO.SearchOption">
            <devdoc>
              Enum describing whether the search operation should
              retrieve files/directories from the current directory alone
              or should include all the subdirectories also.
            </devdoc>
        </member>
        <member name="F:Microsoft.IO.SearchOption.TopDirectoryOnly">
            <devdoc>
              Include only the current directory in the search operation
            </devdoc>
        </member>
        <member name="F:Microsoft.IO.SearchOption.AllDirectories">
            <devdoc>
              Include the current directory and all the sub-directories
              underneath it including reparse points in the search operation.
              This will traverse reparse points (i.e, mounted points and symbolic links)
              recursively. If the directory structure searched contains a loop
              because of hard links, the search operation will go on for ever.
            </devdoc>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified parameter value.</summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>Gets the condition parameter value.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with a field or property member.</summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>Initializes the attribute with the list of field and property members.</summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>Initializes the attribute with the specified return value condition and a field or property member.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>Initializes the attribute with the specified return value condition and list of field and property members.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.IO.DriveInfoInternal">
            <summary>Contains internal volume helpers that are shared between many projects.</summary>
        </member>
        <member name="T:System.IO.PathHelper">
            <summary>
            Wrapper to help with path normalization.
            </summary>
        </member>
        <member name="M:System.IO.PathHelper.Normalize(System.String)">
            <summary>
            Normalize the given path.
            </summary>
            <remarks>
            Normalizes via Win32 GetFullPathName().
            </remarks>
            <param name="path">Path to normalize</param>
            <exception cref="T:System.IO.PathTooLongException">Thrown if we have a string that is too large to fit into a UNICODE_STRING.</exception>
            <exception cref="T:System.IO.IOException">Thrown if the path is empty.</exception>
            <returns>Normalized path</returns>
        </member>
        <member name="M:System.IO.PathHelper.Normalize(System.Text.ValueStringBuilder@)">
            <summary>
            Normalize the given path.
            </summary>
            <remarks>
            Exceptions are the same as the string overload.
            </remarks>
        </member>
        <member name="M:System.IO.PathHelper.GetFullPathName(System.ReadOnlySpan{System.Char},System.Text.ValueStringBuilder@)">
            <summary>
            Calls GetFullPathName on the given path.
            </summary>
            <param name="path">The path name. MUST be null terminated after the span.</param>
            <param name="builder">Builder that will store the result.</param>
        </member>
        <member name="T:System.IO.PathInternal">
            <summary>Contains internal path helpers that are shared between many projects.</summary>
            <summary>Contains internal path helpers that are shared between many projects.</summary>
            <summary>Contains internal path helpers that are shared between many projects.</summary>
        </member>
        <member name="P:System.IO.PathInternal.StringComparison">
            <summary>Returns a comparison that can be used to compare file and directory names for equality.</summary>
        </member>
        <member name="P:System.IO.PathInternal.IsCaseSensitive">
            <summary>Gets whether the system is case-sensitive.</summary>
        </member>
        <member name="M:System.IO.PathInternal.StartsWithDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path starts in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.GetCommonPathLength(System.String,System.String,System.Boolean)">
            <summary>
            Get the common path length from the start of the string.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EqualStartingCharacterCount(System.String,System.String,System.Boolean)">
            <summary>
            Gets the count of common characters from the left optionally ignoring case
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.AreRootsEqual(System.String,System.String,System.StringComparison)">
            <summary>
            Returns true if the two paths have the same root
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.RemoveRelativeSegments(System.String,System.Int32)">
            <summary>
            Try to remove relative segments from the given path (without combining with a root).
            </summary>
            <param name="path">Input path</param>
            <param name="rootLength">The length of the root of the given path</param>
        </member>
        <member name="M:System.IO.PathInternal.RemoveRelativeSegments(System.ReadOnlySpan{System.Char},System.Int32,System.Text.ValueStringBuilder@)">
            <summary>
            Try to remove relative segments from the given path (without combining with a root).
            </summary>
            <param name="path">Input path</param>
            <param name="rootLength">The length of the root of the given path</param>
            <param name="sb">String builder that will store the result</param>
            <returns>"true" if the path was modified</returns>
        </member>
        <member name="M:System.IO.PathInternal.TrimEndingDirectorySeparator(System.String)">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EndsInDirectorySeparator(System.String)">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.TrimEndingDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Trims one trailing directory separator beyond the root of the path.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EndsInDirectorySeparator(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path ends in a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsValidDriveChar(System.Char)">
            <summary>
            Returns true if the given character is a valid drive letter
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EnsureExtendedPrefixIfNeeded(System.String)">
            <summary>
            Adds the extended path prefix (\\?\) if not already a device path, IF the path is not relative,
            AND the path is more than 259 characters. (> MAX_PATH + null). This will also insert the extended
            prefix if the path ends with a period or a space. Trailing periods and spaces are normally eaten
            away from paths during normalization, but if we see such a path at this point it should be
            normalized and has retained the final characters. (Typically from one of the *Info classes)
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.EnsureExtendedPrefix(System.String)">
            <summary>
            Adds the extended path prefix (\\?\) if not relative or already a device path.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsDevice(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path uses any of the DOS device path syntaxes. ("\\.\", "\\?\", or "\??\")
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsDeviceUNC(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path is a device UNC (\\?\UNC\, \\.\UNC\)
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsExtended(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path uses the canonical form of extended syntax ("\\?\" or "\??\"). If the
            path matches exactly (cannot use alternate directory separators) Windows will skip normalization
            and path length checks.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.GetRootLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the length of the root of the path (drive, share, etc.).
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.IsPartiallyQualified(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path specified is relative to the current drive or working directory.
            Returns false if the path is fixed to a specific drive or UNC path.  This method does no
            validation of the path (URIs will be returned as relative as a result).
            </summary>
            <remarks>
            Handles paths that use the alternate directory separator.  It is a frequent mistake to
            assume that rooted paths (Path.IsPathRooted) are not relative.  This isn't the case.
            "C:a" is drive relative- meaning that it will be resolved against the current directory
            for C: (rooted, but relative). "C:\a" is rooted and not relative (the current directory
            will not be used to modify the path).
            </remarks>
        </member>
        <member name="M:System.IO.PathInternal.IsDirectorySeparator(System.Char)">
            <summary>
            True if the given character is a directory separator.
            </summary>
        </member>
        <member name="M:System.IO.PathInternal.NormalizeDirectorySeparators(System.String)">
             <summary>
             Normalize separators in the given path. Converts forward slashes into back slashes and compresses slash runs, keeping initial 2 if present.
             Also trims initial whitespace in front of "rooted" paths (see PathStartSkip).
            
             This effectively replicates the behavior of the legacy NormalizePath when it was called with fullCheck=false and expandShortpaths=false.
             The current NormalizePath gets directory separator normalization from Win32's GetFullPathName(), which will resolve relative paths and as
             such can't be used here (and is overkill for our uses).
            
             Like the current NormalizePath this will not try and analyze periods/spaces within directory segments.
             </summary>
             <remarks>
             The only callers that used to use Path.Normalize(fullCheck=false) were Path.GetDirectoryName() and Path.GetPathRoot(). Both usages do
             not need trimming of trailing whitespace here.
            
             GetPathRoot() could technically skip normalizing separators after the second segment- consider as a future optimization.
            
             For legacy .NET Framework behavior with ExpandShortPaths:
              - It has no impact on GetPathRoot() so doesn't need consideration.
              - It could impact GetDirectoryName(), but only if the path isn't relative (C:\ or \\Server\Share).
            
             In the case of GetDirectoryName() the ExpandShortPaths behavior was undocumented and provided inconsistent results if the path was
             fixed/relative. For example: "C:\PROGRA~1\A.TXT" would return "C:\Program Files" while ".\PROGRA~1\A.TXT" would return ".\PROGRA~1". If you
             ultimately call GetFullPath() this doesn't matter, but if you don't or have any intermediate string handling could easily be tripped up by
             this undocumented behavior.
            
             We won't match this old behavior because:
            
               1. It was undocumented
               2. It was costly (extremely so if it actually contained '~')
               3. Doesn't play nice with string logic
               4. Isn't a cross-plat friendly concept/behavior
             </remarks>
        </member>
        <member name="M:System.IO.PathInternal.IsEffectivelyEmpty(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns true if the path is effectively empty for the current OS.
            For unix, this is empty or null. For Windows, this is empty, null, or
            just spaces ((char)32).
            </summary>
        </member>
        <member name="T:System.IO.Win32Marshal">
            <summary>
            Provides static methods for converting from Win32 errors codes to exceptions, HRESULTS and error messages.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetExceptionForLastWin32Error(System.String)">
            <summary>
            Converts, resetting it, the last Win32 error into a corresponding <see cref="T:System.Exception"/> object, optionally
            including the specified path in the error message.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetExceptionForWin32Error(System.Int32,System.String)">
            <summary>
            Converts the specified Win32 error into a corresponding <see cref="T:System.Exception"/> object, optionally
            including the specified path in the error message.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.MakeHRFromErrorCode(System.Int32)">
            <summary>
            If not already an HRESULT, returns an HRESULT for the specified Win32 error code.
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.TryMakeWin32ErrorCodeFromHR(System.Int32)">
            <summary>
            Returns a Win32 error code for the specified HRESULT if it came from FACILITY_WIN32
            If not, returns the HRESULT unchanged
            </summary>
        </member>
        <member name="M:System.IO.Win32Marshal.GetMessage(System.Int32)">
            <summary>
            Returns a string message for the specified Win32 error code.
            </summary>
        </member>
        <member name="M:System.FixedBufferExtensions.GetStringFromFixedBuffer(System.ReadOnlySpan{System.Char})">
            <summary>
            Returns a string from the given span, terminating the string at null if present.
            </summary>
        </member>
        <member name="M:System.FixedBufferExtensions.GetFixedBufferStringLength(System.ReadOnlySpan{System.Char})">
            <summary>
            Gets the null-terminated string length of the given span.
            </summary>
        </member>
        <member name="M:System.FixedBufferExtensions.FixedBufferEqualsString(System.ReadOnlySpan{System.Char},System.String)">
            <summary>
            Returns true if the given string equals the given span.
            The span's logical length is to the first null if present.
            </summary>
        </member>
        <member name="T:System.Runtime.InteropServices.SuppressGCTransitionAttribute">
             <summary>
             An attribute used to indicate a GC transition should be skipped when making an unmanaged function call.
             </summary>
             <example>
             Example of a valid use case. The Win32 `GetTickCount()` function is a small performance related function
             that reads some global memory and returns the value. In this case, the GC transition overhead is significantly
             more than the memory read.
             <code>
             using System;
             using System.Runtime.InteropServices;
             class Program
             {
                 [DllImport("Kernel32")]
                 [SuppressGCTransition]
                 static extern int GetTickCount();
                 static void Main()
                 {
                     Console.WriteLine($"{GetTickCount()}");
                 }
             }
             </code>
             </example>
             <remarks>
             This attribute is ignored if applied to a method without the <see cref="T:System.Runtime.InteropServices.DllImportAttribute"/>.
            
             Forgoing this transition can yield benefits when the cost of the transition is more than the execution time
             of the unmanaged function. However, avoiding this transition removes some of the guarantees the runtime
             provides through a normal P/Invoke. When exiting the managed runtime to enter an unmanaged function the
             GC must transition from Cooperative mode into Preemptive mode. Full details on these modes can be found at
             https://github.com/dotnet/runtime/blob/main/docs/coding-guidelines/clr-code-guide.md#2.1.8.
             Suppressing the GC transition is an advanced scenario and should not be done without fully understanding
             potential consequences.
            
             One of these consequences is an impact to Mixed-mode debugging (https://docs.microsoft.com/visualstudio/debugger/how-to-debug-in-mixed-mode).
             During Mixed-mode debugging, it is not possible to step into or set breakpoints in a P/Invoke that
             has been marked with this attribute. A workaround is to switch to native debugging and set a breakpoint in the native function.
             In general, usage of this attribute is not recommended if debugging the P/Invoke is important, for example
             stepping through the native code or diagnosing an exception thrown from the native code.
            
             The runtime may load the native library for method marked with this attribute in advance before the method is called for the first time.
             Usage of this attribute is not recommended for platform neutral libraries with conditional platform specific code.
            
             The P/Invoke method that this attribute is applied to must have all of the following properties:
               * Native function always executes for a trivial amount of time (less than 1 microsecond).
               * Native function does not perform a blocking syscall (e.g. any type of I/O).
               * Native function does not call back into the runtime (e.g. Reverse P/Invoke).
               * Native function does not throw exceptions.
               * Native function does not manipulate locks or other concurrency primitives.
            
             Consequences of invalid uses of this attribute:
               * GC starvation.
               * Immediate runtime termination.
               * Data corruption.
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.OSPlatformAttribute">
            <summary>
            Base type for all platform-specific API attributes.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.TargetPlatformAttribute">
            <summary>
            Records the platform that the project targeted.
            </summary>
        </member>
        <member name="T:System.Runtime.Versioning.SupportedOSPlatformAttribute">
             <summary>
             Records the operating system (and minimum version) that supports an API. Multiple attributes can be
             applied to indicate support on multiple operating systems.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.SupportedOSPlatformAttribute" />
             or use guards to prevent calls to APIs on unsupported operating systems.
            
             A given platform should only be specified once.
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.UnsupportedOSPlatformAttribute">
            <summary>
            Marks APIs that were removed in a given operating system version.
            </summary>
            <remarks>
            Primarily used by OS bindings to indicate APIs that are only available in
            earlier versions.
            </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.SupportedOSPlatformGuardAttribute">
             <summary>
             Annotates a custom guard field, property or method with a supported platform name and optional version.
             Multiple attributes can be applied to indicate guard for multiple supported platforms.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.SupportedOSPlatformGuardAttribute" /> to a field, property or method
             and use that field, property or method in a conditional or assert statements in order to safely call platform specific APIs.
            
             The type of the field or property should be boolean, the method return type should be boolean in order to be used as platform guard.
             </remarks>
        </member>
        <member name="T:System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute">
             <summary>
             Annotates the custom guard field, property or method with an unsupported platform name and optional version.
             Multiple attributes can be applied to indicate guard for multiple unsupported platforms.
             </summary>
             <remarks>
             Callers can apply a <see cref="T:System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute" /> to a field, property or method
             and use that  field, property or method in a conditional or assert statements as a guard to safely call APIs unsupported on those platforms.
            
             The type of the field or property should be boolean, the method return type should be boolean in order to be used as platform guard.
             </remarks>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference">
            <summary>
            Get a pinnable reference to the builder.
            Does not ensure there is a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/>
            This overload is pattern matched in the C# 7.3+ compiler so you can omit
            the explicit method call, and write eg "fixed (char* c = builder)"
            </summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="P:System.Text.ValueStringBuilder.RawChars">
            <summary>Returns the underlying storage of the builder.</summary>
        </member>
        <member name="M:System.Text.ValueStringBuilder.AsSpan(System.Boolean)">
            <summary>
            Returns a span around the contents of the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:System.Text.ValueStringBuilder.Length"/></param>
        </member>
        <member name="M:System.Text.ValueStringBuilder.Grow(System.Int32)">
            <summary>
            Resize the internal buffer either by doubling current buffer size or
            by adding <paramref name="additionalCapacityBeyondPos"/> to
            <see cref="F:System.Text.ValueStringBuilder._pos"/> whichever is greater.
            </summary>
            <param name="additionalCapacityBeyondPos">
            Number of chars requested beyond current position.
            </param>
        </member>
        <member name="P:System.SR.Arg_FileIsDirectory_Name">
            <summary>The target file '{0}' is a directory, not a file.</summary>
        </member>
        <member name="P:System.SR.Arg_InvalidFileAttrs">
            <summary>Invalid File or Directory attributes value.</summary>
        </member>
        <member name="P:System.SR.Arg_Path2IsRooted">
            <summary>Second path fragment must not be a drive or UNC name.</summary>
        </member>
        <member name="P:System.SR.Arg_PathIsVolume">
            <summary>Path must not be a drive.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_FileName">
            <summary>File name cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentNull_Path">
            <summary>Path cannot be null.</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_Enum">
            <summary>Enum value was out of legal range.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyFileName">
            <summary>Empty file name is not legal.</summary>
        </member>
        <member name="P:System.SR.Argument_EmptyPath">
            <summary>Empty path name is not legal.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidPathChars">
            <summary>Illegal characters in path '{0}'.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidSeekOrigin">
            <summary>Invalid seek origin.</summary>
        </member>
        <member name="P:System.SR.Argument_InvalidSubPath">
            <summary>The directory specified, '{0}', is not a subdirectory of '{1}'.</summary>
        </member>
        <member name="P:System.SR.Argument_PathEmpty">
            <summary>Path cannot be the empty string or all whitespace.</summary>
        </member>
        <member name="P:System.SR.IO_AlreadyExists_Name">
            <summary>Cannot create '{0}' because a file or directory with the same name already exists.</summary>
        </member>
        <member name="P:System.SR.IO_CannotCreateDirectory">
            <summary>The specified directory '{0}' cannot be created.</summary>
        </member>
        <member name="P:System.SR.IO_EOF_ReadBeyondEOF">
            <summary>Unable to read beyond the end of the stream.</summary>
        </member>
        <member name="P:System.SR.IO_FileExists_Name">
            <summary>The file '{0}' already exists.</summary>
        </member>
        <member name="P:System.SR.IO_FileNotFound">
            <summary>Unable to find the specified file.</summary>
        </member>
        <member name="P:System.SR.IO_FileNotFound_FileName">
            <summary>Could not find file '{0}'.</summary>
        </member>
        <member name="P:System.SR.IO_FileTooLong2GB">
            <summary>The file is too long. This operation is currently limited to supporting files less than 2 gigabytes in size.</summary>
        </member>
        <member name="P:System.SR.IO_InconsistentLinkType">
            <summary>The link's file system entry type is inconsistent with that of its target: {0}</summary>
        </member>
        <member name="P:System.SR.IO_PathNotFound_NoPathName">
            <summary>Could not find a part of the path.</summary>
        </member>
        <member name="P:System.SR.IO_PathNotFound_Path">
            <summary>Could not find a part of the path '{0}'.</summary>
        </member>
        <member name="P:System.SR.IO_PathTooLong">
            <summary>The specified file name or path is too long, or a component of the specified path is too long.</summary>
        </member>
        <member name="P:System.SR.IO_SharingViolation_File">
            <summary>The process cannot access the file '{0}' because it is being used by another process.</summary>
        </member>
        <member name="P:System.SR.IO_SharingViolation_NoFileName">
            <summary>The process cannot access the file because it is being used by another process.</summary>
        </member>
        <member name="P:System.SR.IO_SourceDestMustBeDifferent">
            <summary>Source and destination path must be different.</summary>
        </member>
        <member name="P:System.SR.IO_SourceDestMustHaveSameRoot">
            <summary>Source and destination path must have identical roots. Move will not work across volumes.</summary>
        </member>
        <member name="P:System.SR.IO_UnknownFileName">
            <summary>[Unknown]</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_IODenied_NoPathName">
            <summary>Access to the path is denied.</summary>
        </member>
        <member name="P:System.SR.UnauthorizedAccess_IODenied_Path">
            <summary>Access to the path '{0}' is denied.</summary>
        </member>
        <member name="P:System.SR.PlatformNotSupported_FileEncryption">
            <summary>File encryption is not supported on this platform.</summary>
        </member>
        <member name="P:System.SR.IO_PathTooLong_Path">
            <summary>The path '{0}' is too long, or a component of the specified path is too long.</summary>
        </member>
        <member name="P:System.SR.Arg_BasePathNotFullyQualified">
            <summary>Basepath argument is not fully qualified.</summary>
        </member>
        <member name="P:System.SR.Arg_PathEmpty">
            <summary>The path is empty.</summary>
        </member>
        <member name="P:System.SR.Arg_MustBeDriveLetterOrRootDir">
            <summary>Drive name must be a root directory (i.e. 'C:\') or a drive letter ('C').</summary>
        </member>
        <member name="P:System.SR.ArgumentOutOfRange_NeedNonNegNum">
            <summary>Non-negative number required.</summary>
        </member>
    </members>
</doc>
